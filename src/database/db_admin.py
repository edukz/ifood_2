"""
Administra√ß√£o do banco de dados
"""
import os
import time
from pathlib import Path
from colorama import Fore, Style
from src.utils.logger import get_logger
from src.database.db_manager import DatabaseManager

class DatabaseAdmin:
    def __init__(self):
        self.logger = get_logger()
        self.db_manager = DatabaseManager()
    
    def _format_size(self, size_bytes):
        """Formatar tamanho em bytes para formato leg√≠vel"""
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size_bytes < 1024.0:
                return f"{size_bytes:.1f}{unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.1f}TB"
    
    def show_structure(self):
        """Ver estrutura das tabelas"""
        try:
            print(f"\n{Fore.CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
            print(f"{Fore.CYAN}‚ïë               ESTRUTURA DAS TABELAS                      ‚ïë")
            print(f"{Fore.CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
            
            conn = self.db_manager._get_connection()
            
            # Listar todas as tabelas
            tables_query = """
                SELECT table_name 
                FROM information_schema.tables 
                WHERE table_schema = 'main' 
                ORDER BY table_name
            """
            tables = conn.execute(tables_query).fetchall()
            
            if not tables:
                print(f"\n{Fore.YELLOW}‚ö†Ô∏è Nenhuma tabela encontrada no banco de dados!")
                conn.close()
                input(f"\n{Fore.GREEN}Pressione ENTER para continuar...")
                return
            
            print(f"\n{Fore.WHITE}üìä Total de tabelas encontradas: {len(tables)}")
            print(f"{Fore.MAGENTA}{'‚îÄ'*60}")
            
            for table in tables:
                table_name = table[0]
                print(f"\n{Fore.YELLOW}üìã TABELA: {table_name.upper()}")
                
                # Obter estrutura da tabela
                structure = conn.execute(f"DESCRIBE {table_name}").fetchall()
                
                # Obter contagem de registros
                count = conn.execute(f"SELECT COUNT(*) FROM {table_name}").fetchone()[0]
                
                print(f"{Fore.CYAN}   üìä Registros: {count:,}")
                print(f"{Fore.CYAN}   üèóÔ∏è  Estrutura:")
                
                # Cabe√ßalho da tabela de estrutura
                print(f"{Fore.WHITE}      {'Campo':<20} {'Tipo':<15} {'Nulo':<8} {'Chave':<10}")
                print(f"{Fore.WHITE}      {'-'*20} {'-'*15} {'-'*8} {'-'*10}")
                
                for col in structure:
                    col_name = col[0]
                    col_type = col[1]
                    is_null = "Sim" if col[2] else "N√£o"
                    is_key = "PK" if col[3] else "-"
                    
                    print(f"{Fore.GREEN}      {col_name:<20} {col_type:<15} {is_null:<8} {is_key:<10}")
                
                # Verificar se h√° √≠ndices
                try:
                    indexes_query = f"""
                        SELECT sql FROM sqlite_master 
                        WHERE type = 'index' AND tbl_name = '{table_name}' 
                        AND sql IS NOT NULL
                    """
                    indexes = conn.execute(indexes_query).fetchall()
                    
                    if indexes:
                        print(f"{Fore.YELLOW}   üîç √çndices:")
                        for idx in indexes:
                            idx_sql = idx[0]
                            print(f"{Fore.CYAN}      ‚Ä¢ {idx_sql}")
                    else:
                        print(f"{Fore.YELLOW}   üîç √çndices: Nenhum √≠ndice customizado")
                except:
                    # DuckDB pode n√£o ter sqlite_master
                    print(f"{Fore.YELLOW}   üîç √çndices: Informa√ß√£o n√£o dispon√≠vel")
                
                print(f"{Fore.MAGENTA}   {'-'*50}")
            
            conn.close()
            
        except Exception as e:
            self.logger.error(f"Erro ao mostrar estrutura: {str(e)}")
            print(f"\n{Fore.RED}‚ùå Erro ao obter estrutura das tabelas: {str(e)}")
        
        input(f"\n{Fore.GREEN}Pressione ENTER para continuar...")
    
    def manage_indexes(self):
        """Criar/alterar √≠ndices"""
        try:
            print(f"\n{Fore.CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
            print(f"{Fore.CYAN}‚ïë                  GERENCIAR √çNDICES                       ‚ïë")
            print(f"{Fore.CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
            
            while True:
                print(f"\n{Fore.YELLOW}OP√á√ïES DE √çNDICES:")
                print(f"{Fore.WHITE}[1] Criar √≠ndices recomendados")
                print(f"{Fore.WHITE}[2] Listar √≠ndices existentes")
                print(f"{Fore.WHITE}[3] Criar √≠ndice personalizado")
                print(f"{Fore.WHITE}[4] Remover √≠ndice")
                print(f"{Fore.RED}[0] Voltar")
                
                choice = input(f"\n{Fore.GREEN}Escolha: {Style.RESET_ALL}").strip()
                
                if choice == '0':
                    break
                elif choice == '1':
                    self._create_recommended_indexes()
                elif choice == '2':
                    self._list_indexes()
                elif choice == '3':
                    self._create_custom_index()
                elif choice == '4':
                    self._remove_index()
                else:
                    print(f"{Fore.RED}Op√ß√£o inv√°lida!")
                    input(f"{Fore.GREEN}Pressione ENTER para continuar...")
                    
        except Exception as e:
            self.logger.error(f"Erro no gerenciamento de √≠ndices: {str(e)}")
            print(f"\n{Fore.RED}‚ùå Erro: {str(e)}")
            input(f"\n{Fore.GREEN}Pressione ENTER para continuar...")
    
    def _create_recommended_indexes(self):
        """Criar √≠ndices recomendados para performance"""
        try:
            print(f"\n{Fore.CYAN}üîç CRIANDO √çNDICES RECOMENDADOS...")
            
            conn = self.db_manager._get_connection()
            
            # √çndices recomendados para melhorar performance
            recommended_indexes = [
                ("idx_restaurants_city", "restaurants", "city"),
                ("idx_restaurants_category", "restaurants", "category"),
                ("idx_restaurants_rating", "restaurants", "rating"),
                ("idx_products_restaurant_id", "products", "restaurant_id"),
                ("idx_products_category", "products", "category"),
                ("idx_products_price", "products", "price"),
                ("idx_categories_name", "categories", "categorias"),
                ("idx_restaurants_name", "restaurants", "name")
            ]
            
            created_count = 0
            skipped_count = 0
            
            for idx_name, table_name, column_name in recommended_indexes:
                try:
                    # Verificar se a tabela existe
                    table_exists = conn.execute(f"""
                        SELECT COUNT(*) FROM information_schema.tables 
                        WHERE table_name = '{table_name}'
                    """).fetchone()[0]
                    
                    if table_exists == 0:
                        print(f"{Fore.YELLOW}   ‚ö†Ô∏è Tabela '{table_name}' n√£o existe - pulando √≠ndice {idx_name}")
                        skipped_count += 1
                        continue
                    
                    # Tentar criar √≠ndice
                    create_sql = f"CREATE INDEX IF NOT EXISTS {idx_name} ON {table_name}({column_name})"
                    conn.execute(create_sql)
                    
                    print(f"{Fore.GREEN}   ‚úÖ √çndice criado: {idx_name} em {table_name}({column_name})")
                    created_count += 1
                    
                except Exception as e:
                    print(f"{Fore.RED}   ‚ùå Erro ao criar {idx_name}: {str(e)}")
                    skipped_count += 1
            
            conn.commit()
            conn.close()
            
            print(f"\n{Fore.CYAN}üìä RESUMO:")
            print(f"{Fore.GREEN}   ‚úÖ √çndices criados: {created_count}")
            print(f"{Fore.YELLOW}   ‚ö†Ô∏è √çndices pulados: {skipped_count}")
            
        except Exception as e:
            print(f"{Fore.RED}‚ùå Erro ao criar √≠ndices recomendados: {str(e)}")
        
        input(f"\n{Fore.GREEN}Pressione ENTER para continuar...")
    
    def _list_indexes(self):
        """Listar √≠ndices existentes"""
        try:
            print(f"\n{Fore.CYAN}üìã √çNDICES EXISTENTES:")
            
            conn = self.db_manager._get_connection()
            
            # Tentar listar √≠ndices (m√©todo pode variar entre bancos)
            try:
                # Para DuckDB/SQLite
                indexes = conn.execute("""
                    SELECT name, sql FROM sqlite_master 
                    WHERE type = 'index' AND sql IS NOT NULL
                    ORDER BY name
                """).fetchall()
                
                if indexes:
                    print(f"{Fore.WHITE}{'Nome do √çndice':<30} {'Defini√ß√£o'}")
                    print(f"{Fore.WHITE}{'-'*30} {'-'*40}")
                    
                    for idx in indexes:
                        idx_name = idx[0]
                        idx_sql = idx[1]
                        print(f"{Fore.GREEN}{idx_name:<30} {idx_sql}")
                else:
                    print(f"{Fore.YELLOW}   ‚ö†Ô∏è Nenhum √≠ndice personalizado encontrado")
                    
            except:
                # M√©todo alternativo se sqlite_master n√£o estiver dispon√≠vel
                print(f"{Fore.YELLOW}   ‚ö†Ô∏è Informa√ß√µes de √≠ndices n√£o dispon√≠veis para este tipo de banco")
            
            conn.close()
            
        except Exception as e:
            print(f"{Fore.RED}‚ùå Erro ao listar √≠ndices: {str(e)}")
        
        input(f"\n{Fore.GREEN}Pressione ENTER para continuar...")
    
    def _create_custom_index(self):
        """Criar √≠ndice personalizado"""
        try:
            print(f"\n{Fore.CYAN}üîß CRIAR √çNDICE PERSONALIZADO:")
            
            # Listar tabelas dispon√≠veis
            conn = self.db_manager._get_connection()
            tables = conn.execute("""
                SELECT table_name FROM information_schema.tables 
                WHERE table_schema = 'main' ORDER BY table_name
            """).fetchall()
            
            if not tables:
                print(f"{Fore.YELLOW}‚ö†Ô∏è Nenhuma tabela encontrada!")
                conn.close()
                return
            
            print(f"{Fore.WHITE}Tabelas dispon√≠veis:")
            for i, table in enumerate(tables, 1):
                print(f"{Fore.YELLOW}[{i}] {table[0]}")
            
            table_choice = int(input(f"\n{Fore.WHITE}Escolha uma tabela: ")) - 1
            
            if 0 <= table_choice < len(tables):
                table_name = tables[table_choice][0]
                
                # Listar colunas da tabela
                columns = conn.execute(f"DESCRIBE {table_name}").fetchall()
                
                print(f"\n{Fore.WHITE}Colunas dispon√≠veis em '{table_name}':")
                for i, col in enumerate(columns, 1):
                    print(f"{Fore.YELLOW}[{i}] {col[0]} ({col[1]})")
                
                col_choice = int(input(f"\n{Fore.WHITE}Escolha uma coluna: ")) - 1
                
                if 0 <= col_choice < len(columns):
                    column_name = columns[col_choice][0]
                    
                    idx_name = input(f"\n{Fore.WHITE}Nome do √≠ndice (ou ENTER para autom√°tico): ").strip()
                    if not idx_name:
                        idx_name = f"idx_{table_name}_{column_name}"
                    
                    # Criar √≠ndice
                    create_sql = f"CREATE INDEX IF NOT EXISTS {idx_name} ON {table_name}({column_name})"
                    conn.execute(create_sql)
                    conn.commit()
                    
                    print(f"\n{Fore.GREEN}‚úÖ √çndice '{idx_name}' criado com sucesso!")
                else:
                    print(f"{Fore.RED}Coluna inv√°lida!")
            else:
                print(f"{Fore.RED}Tabela inv√°lida!")
            
            conn.close()
            
        except (ValueError, IndexError):
            print(f"{Fore.RED}‚ùå Entrada inv√°lida!")
        except Exception as e:
            print(f"{Fore.RED}‚ùå Erro ao criar √≠ndice: {str(e)}")
        
        input(f"\n{Fore.GREEN}Pressione ENTER para continuar...")
    
    def _remove_index(self):
        """Remover √≠ndice"""
        try:
            print(f"\n{Fore.CYAN}üóëÔ∏è REMOVER √çNDICE:")
            
            conn = self.db_manager._get_connection()
            
            # Listar √≠ndices existentes
            try:
                indexes = conn.execute("""
                    SELECT name FROM sqlite_master 
                    WHERE type = 'index' AND sql IS NOT NULL
                    ORDER BY name
                """).fetchall()
                
                if not indexes:
                    print(f"{Fore.YELLOW}‚ö†Ô∏è Nenhum √≠ndice personalizado encontrado!")
                    conn.close()
                    return
                
                print(f"{Fore.WHITE}√çndices dispon√≠veis:")
                for i, idx in enumerate(indexes, 1):
                    print(f"{Fore.YELLOW}[{i}] {idx[0]}")
                
                idx_choice = int(input(f"\n{Fore.WHITE}Escolha um √≠ndice para remover: ")) - 1
                
                if 0 <= idx_choice < len(indexes):
                    idx_name = indexes[idx_choice][0]
                    
                    confirm = input(f"\n{Fore.RED}Confirma remo√ß√£o do √≠ndice '{idx_name}'? (s/N): ").strip().lower()
                    
                    if confirm == 's':
                        conn.execute(f"DROP INDEX IF EXISTS {idx_name}")
                        conn.commit()
                        print(f"\n{Fore.GREEN}‚úÖ √çndice '{idx_name}' removido!")
                    else:
                        print(f"\n{Fore.CYAN}Opera√ß√£o cancelada.")
                else:
                    print(f"{Fore.RED}√çndice inv√°lido!")
                    
            except:
                print(f"{Fore.YELLOW}‚ö†Ô∏è N√£o foi poss√≠vel listar √≠ndices")
            
            conn.close()
            
        except (ValueError, IndexError):
            print(f"{Fore.RED}‚ùå Entrada inv√°lida!")
        except Exception as e:
            print(f"{Fore.RED}‚ùå Erro ao remover √≠ndice: {str(e)}")
        
        input(f"\n{Fore.GREEN}Pressione ENTER para continuar...")
    
    def analyze_performance(self):
        """Analisar performance de consultas"""
        try:
            print(f"\n{Fore.CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
            print(f"{Fore.CYAN}‚ïë                AN√ÅLISE DE PERFORMANCE                    ‚ïë")
            print(f"{Fore.CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
            
            conn = self.db_manager._get_connection()
            
            # An√°lise b√°sica de performance
            print(f"\n{Fore.YELLOW}üìä ESTAT√çSTICAS GERAIS:")
            
            # Verificar tamanhos das tabelas
            tables = conn.execute("""
                SELECT table_name FROM information_schema.tables 
                WHERE table_schema = 'main' ORDER BY table_name
            """).fetchall()
            
            print(f"{Fore.WHITE}{'Tabela':<20} {'Registros':<12} {'Performance'}")
            print(f"{Fore.WHITE}{'-'*20} {'-'*12} {'-'*15}")
            
            total_records = 0
            
            for table in tables:
                table_name = table[0]
                
                # Contar registros com medi√ß√£o de tempo
                start_time = time.time()
                count = conn.execute(f"SELECT COUNT(*) FROM {table_name}").fetchone()[0]
                query_time = time.time() - start_time
                
                total_records += count
                
                # An√°lise de performance baseada no tempo de consulta
                if query_time < 0.1:
                    perf_status = f"{Fore.GREEN}Excelente"
                elif query_time < 0.5:
                    perf_status = f"{Fore.YELLOW}Boa"
                elif query_time < 1.0:
                    perf_status = f"{Fore.YELLOW}Aceit√°vel"
                else:
                    perf_status = f"{Fore.RED}Lenta"
                
                print(f"{Fore.CYAN}{table_name:<20} {count:,<12} {perf_status} ({query_time:.3f}s)")
            
            print(f"\n{Fore.WHITE}üìà Total de registros: {total_records:,}")
            
            # Teste de consultas complexas
            print(f"\n{Fore.YELLOW}üîç TESTE DE CONSULTAS COMPLEXAS:")
            
            complex_queries = [
                ("Restaurantes por categoria", "SELECT category, COUNT(*) FROM restaurants GROUP BY category"),
                ("Produtos mais caros", "SELECT restaurant_name, name, price FROM products WHERE price IS NOT NULL ORDER BY price DESC LIMIT 10"),
                ("Estat√≠sticas de rating", "SELECT AVG(rating), MIN(rating), MAX(rating) FROM restaurants WHERE rating IS NOT NULL")
            ]
            
            for query_name, sql in complex_queries:
                try:
                    start_time = time.time()
                    result = conn.execute(sql).fetchall()
                    query_time = time.time() - start_time
                    
                    if query_time < 0.1:
                        perf_icon = f"{Fore.GREEN}‚ö°"
                    elif query_time < 0.5:
                        perf_icon = f"{Fore.YELLOW}‚è±Ô∏è"
                    else:
                        perf_icon = f"{Fore.RED}üêå"
                    
                    print(f"{perf_icon} {query_name}: {query_time:.3f}s ({len(result)} resultados)")
                    
                except Exception as e:
                    print(f"{Fore.RED}‚ùå {query_name}: Erro - {str(e)}")
            
            # Recomenda√ß√µes de otimiza√ß√£o
            print(f"\n{Fore.YELLOW}üí° RECOMENDA√á√ïES DE OTIMIZA√á√ÉO:")
            
            # Verificar se h√° tabelas grandes sem √≠ndices
            for table in tables:
                table_name = table[0]
                count = conn.execute(f"SELECT COUNT(*) FROM {table_name}").fetchone()[0]
                
                if count > 1000:
                    print(f"{Fore.CYAN}‚Ä¢ Tabela '{table_name}' tem {count:,} registros")
                    print(f"{Fore.WHITE}  Recomenda-se criar √≠ndices em colunas frequentemente consultadas")
            
            # Verificar fragmenta√ß√£o (simulado)
            if total_records > 10000:
                print(f"{Fore.CYAN}‚Ä¢ Banco com {total_records:,} registros")
                print(f"{Fore.WHITE}  Considere executar VACUUM periodicamente")
            
            conn.close()
            
        except Exception as e:
            self.logger.error(f"Erro na an√°lise de performance: {str(e)}")
            print(f"\n{Fore.RED}‚ùå Erro na an√°lise: {str(e)}")
        
        input(f"\n{Fore.GREEN}Pressione ENTER para continuar...")
    
    def check_size(self):
        """Verificar tamanho do banco"""
        try:
            print(f"\n{Fore.CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
            print(f"{Fore.CYAN}‚ïë                 TAMANHO DO BANCO                         ‚ïë")
            print(f"{Fore.CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
            
            # Verificar tamanho do arquivo do banco
            db_path = self.db_manager.db_path
            
            if os.path.exists(db_path):
                file_size = os.path.getsize(db_path)
                print(f"\n{Fore.WHITE}üìÅ Arquivo do banco: {db_path}")
                print(f"{Fore.GREEN}üìä Tamanho do arquivo: {self._format_size(file_size)}")
            else:
                print(f"\n{Fore.YELLOW}‚ö†Ô∏è Arquivo do banco n√£o encontrado: {db_path}")
                return
            
            # An√°lise por tabela
            conn = self.db_manager._get_connection()
            
            print(f"\n{Fore.YELLOW}üìã AN√ÅLISE POR TABELA:")
            print(f"{Fore.WHITE}{'Tabela':<20} {'Registros':<12} {'Est. Tamanho':<12} {'%':<8}")
            print(f"{Fore.WHITE}{'-'*20} {'-'*12} {'-'*12} {'-'*8}")
            
            tables = conn.execute("""
                SELECT table_name FROM information_schema.tables 
                WHERE table_schema = 'main' ORDER BY table_name
            """).fetchall()
            
            total_records = 0
            table_sizes = []
            
            for table in tables:
                table_name = table[0]
                count = conn.execute(f"SELECT COUNT(*) FROM {table_name}").fetchone()[0]
                total_records += count
                
                # Estimativa de tamanho baseada no n√∫mero de registros
                # (estimativa aproximada: ~500 bytes por registro em m√©dia)
                estimated_size = count * 500
                table_sizes.append((table_name, count, estimated_size))
            
            # Calcular percentuais
            for table_name, count, estimated_size in table_sizes:
                percentage = (count / total_records * 100) if total_records > 0 else 0
                
                print(f"{Fore.CYAN}{table_name:<20} {count:,<12} {self._format_size(estimated_size):<12} {percentage:.1f}%")
            
            print(f"\n{Fore.WHITE}üìà RESUMO GERAL:")
            print(f"{Fore.GREEN}   ‚Ä¢ Total de registros: {total_records:,}")
            print(f"{Fore.GREEN}   ‚Ä¢ Total de tabelas: {len(tables)}")
            print(f"{Fore.GREEN}   ‚Ä¢ Tamanho do arquivo: {self._format_size(file_size)}")
            
            # Verificar espa√ßo em disco dispon√≠vel
            try:
                import shutil
                free_space = shutil.disk_usage(os.path.dirname(db_path)).free
                print(f"{Fore.CYAN}   ‚Ä¢ Espa√ßo livre em disco: {self._format_size(free_space)}")
                
                # Alertas baseados no espa√ßo dispon√≠vel
                if free_space < file_size * 10:  # Menos que 10x o tamanho do banco
                    print(f"{Fore.YELLOW}   ‚ö†Ô∏è Pouco espa√ßo em disco dispon√≠vel!")
                
            except:
                print(f"{Fore.YELLOW}   ‚Ä¢ Espa√ßo em disco: N√£o foi poss√≠vel verificar")
            
            # Hist√≥rico de crescimento (simulado)
            print(f"\n{Fore.YELLOW}üìà INFORMA√á√ïES ADICIONAIS:")
            
            # Verificar quando foi a √∫ltima modifica√ß√£o
            mod_time = os.path.getmtime(db_path)
            from datetime import datetime
            last_mod = datetime.fromtimestamp(mod_time).strftime("%d/%m/%Y %H:%M:%S")
            print(f"{Fore.CYAN}   ‚Ä¢ √öltima modifica√ß√£o: {last_mod}")
            
            # Idade do arquivo
            age_days = (time.time() - mod_time) / (24 * 3600)
            print(f"{Fore.CYAN}   ‚Ä¢ Idade do banco: {age_days:.1f} dias")
            
            if age_days > 30:
                print(f"{Fore.YELLOW}   üí° Considere fazer backup peri√≥dico")
            
            conn.close()
            
        except Exception as e:
            self.logger.error(f"Erro ao verificar tamanho: {str(e)}")
            print(f"\n{Fore.RED}‚ùå Erro ao verificar tamanho: {str(e)}")
        
        input(f"\n{Fore.GREEN}Pressione ENTER para continuar...")
    
    def vacuum_database(self):
        """Vacuum/otimizar banco"""
        try:
            print(f"\n{Fore.CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
            print(f"{Fore.CYAN}‚ïë               OTIMIZA√á√ÉO DO BANCO                        ‚ïë")
            print(f"{Fore.CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
            
            # Verificar tamanho antes
            db_path = self.db_manager.db_path
            if not os.path.exists(db_path):
                print(f"\n{Fore.YELLOW}‚ö†Ô∏è Arquivo do banco n√£o encontrado!")
                return
            
            size_before = os.path.getsize(db_path)
            print(f"\n{Fore.WHITE}üìä Tamanho antes da otimiza√ß√£o: {self._format_size(size_before)}")
            
            # Confirmar opera√ß√£o
            print(f"\n{Fore.YELLOW}‚ö†Ô∏è ATEN√á√ÉO:")
            print(f"{Fore.WHITE}A otimiza√ß√£o pode demorar alguns minutos dependendo do tamanho do banco.")
            print(f"{Fore.WHITE}Durante o processo, o banco ficar√° temporariamente bloqueado.")
            
            confirm = input(f"\n{Fore.CYAN}Continuar com a otimiza√ß√£o? (s/N): ").strip().lower()
            
            if confirm != 's':
                print(f"\n{Fore.CYAN}Opera√ß√£o cancelada.")
                return
            
            print(f"\n{Fore.CYAN}üîß Iniciando otimiza√ß√£o...")
            
            conn = self.db_manager._get_connection()
            
            start_time = time.time()
            
            # Executar comandos de otimiza√ß√£o
            optimization_commands = [
                ("VACUUM", "Desfragmenta√ß√£o do banco"),
                ("ANALYZE", "Atualiza√ß√£o de estat√≠sticas"),
            ]
            
            for command, description in optimization_commands:
                try:
                    print(f"{Fore.YELLOW}   üîÑ {description}...")
                    conn.execute(command)
                    print(f"{Fore.GREEN}   ‚úÖ {description} conclu√≠da")
                except Exception as e:
                    print(f"{Fore.RED}   ‚ùå Erro em {description}: {str(e)}")
            
            # Recriar estat√≠sticas para tabelas espec√≠ficas
            try:
                tables = conn.execute("""
                    SELECT table_name FROM information_schema.tables 
                    WHERE table_schema = 'main'
                """).fetchall()
                
                print(f"{Fore.YELLOW}   üîÑ Atualizando estat√≠sticas das tabelas...")
                for table in tables:
                    try:
                        conn.execute(f"ANALYZE {table[0]}")
                    except:
                        pass  # Nem todos os bancos suportam ANALYZE por tabela
                
                print(f"{Fore.GREEN}   ‚úÖ Estat√≠sticas atualizadas")
                
            except:
                print(f"{Fore.YELLOW}   ‚ö†Ô∏è Atualiza√ß√£o de estat√≠sticas n√£o dispon√≠vel")
            
            conn.close()
            
            # Verificar tamanho depois
            size_after = os.path.getsize(db_path)
            optimization_time = time.time() - start_time
            
            print(f"\n{Fore.GREEN}üéØ OTIMIZA√á√ÉO CONCLU√çDA!")
            print(f"{Fore.WHITE}‚è±Ô∏è  Tempo de execu√ß√£o: {optimization_time:.2f} segundos")
            print(f"{Fore.WHITE}üìä Tamanho antes: {self._format_size(size_before)}")
            print(f"{Fore.WHITE}üìä Tamanho depois: {self._format_size(size_after)}")
            
            # Calcular economia
            if size_after < size_before:
                saved_space = size_before - size_after
                saved_percent = (saved_space / size_before) * 100
                print(f"{Fore.GREEN}üíæ Espa√ßo economizado: {self._format_size(saved_space)} ({saved_percent:.1f}%)")
            elif size_after > size_before:
                print(f"{Fore.YELLOW}üìà Tamanho aumentou (normal ap√≥s reorganiza√ß√£o)")
            else:
                print(f"{Fore.CYAN}üìä Tamanho mantido (banco j√° estava otimizado)")
            
            print(f"\n{Fore.CYAN}üí° RECOMENDA√á√ïES:")
            print(f"{Fore.WHITE}   ‚Ä¢ Execute VACUUM mensalmente em bancos com alta atividade")
            print(f"{Fore.WHITE}   ‚Ä¢ Monitore o crescimento do banco regularmente")
            print(f"{Fore.WHITE}   ‚Ä¢ Considere arquivar dados antigos se necess√°rio")
            
        except Exception as e:
            self.logger.error(f"Erro na otimiza√ß√£o: {str(e)}")
            print(f"\n{Fore.RED}‚ùå Erro durante otimiza√ß√£o: {str(e)}")
        
        input(f"\n{Fore.GREEN}Pressione ENTER para continuar...")